"""
"" 20th OCT 2025 ::: Irfan Habeeb Gazi
"" 29th OCT 2025 ::: Surjayan Kar
"" 1st NOV 2025 ::: Vivek Halder
""
"" Usage: sage Decrypt.py <priv_key> <pub_key> <ciphertext>
""
"" This program decrypts a given ciphertext (stored as a pair of points) using Elliptic Curve Cryptography.
"" The private and public key files must generated by the user and stored in the corresponding files.
"" Please refer to KeyGeneration.py and KeyGenerationUtil.py for more details.
"" The ciphertext is expected to encrypted by the sender using Encrypt.py. Please refer to the program for more details.
"" The decyprted message is printed to the console.
""
"" The arguments to be provided to the program are as follows:
"" 1. <mode>: 0 = single point decryption, 1 = output ASCII message, 2 = batch point decryption
"" 2. <priv_key> : The path to file containing the private key.
"" 3. <public_key> : The path to file containing the public key for the cryptosystem. This file also
"" stores the elliptic curve parameters to be used.
"" 4. <ciphertext> : The ciphertext to be decrypted. This file must be generated by the sender
"" using Encrypt.py on a valid message. It may contain a single ciphertext (mode 0 and 1)
"" or multiple ciphertexts (mode 1 and 2).
""
"" <Sample Input / Output>
""
"" INPUT 1:
"" Mode: 0
"" ecc_public_key.txt:-
"" {
"" public_key": "(7 : 13*a + 1 : 1)",
"" generator": "(8 : 16*a + 7 : 1)",
"" coefficients": "(2, 3, 5, 7, 11)",
"" field_order": "289",
"" field_degree": "2"
"" }
""
"" ecc_private_key.txt:-
"" {
"" private_key": "13"
"" }
""
"" ecc_ciphertext.txt:-
"" {
"" C1": "(14 : 11*a + 12 : 1)",
"" C2": "(14*a + 13 : 16*a + 12 : 1)"
"" }
""
"" OUTPUT 1:
"" Decrypted Message Point M: (12 : 2 : 1)
""
"" Time Taken - 0.678s (Linux x86_64 - ASUS TUF 2022)
""
"" INPUT 2:
"" Mode: 1
"" ecc_public_key.txt:-
"" {
"" private_key": "6563055181661566809356460026291252128518630419258493843098257729406741767750"
"" }
""
"" ecc_public_key.txt:-
"" {
"" "public_key": "(33826589915974876451303538711434911780771211905044168883402609147833006747732 : 27566994943980390140539650248379388081128599148510027697475930812689256311866 : 1)",
"" "generator": "(9 : 14781619447589544791020593568409986887264606134616475288964881837755586237401 : 1)",
"" "coefficients": "(0, 486662, 0, 1, 0)",
"" "base_field": "57896044618658097711785492504343953926634992332820282019728792003956564819949",
"" "field_degree": "1"
"" }
""
"" ecc_ciphertext.txt:-
"" {
"" "C1": "(31894743248758571947732118035776289069590431853604163486169561500672450626470 : 17022476366370823369904501506306283319725097315687443836148662080126252360294 : 1)",
"" "C2": "(32710928097340310354198571803413987008186855435925972928960974582482408697236 : 27263700611213709848986074990488688584781464945924217181237791975065342270456 : 1)"
"" }
""
"" OUTPUT 2:
"" Decrypted ASCII Message: blue
""
"" Time Taken - 0.692s (Linux x86_64 - ASUS TUF 2022)
""
"" INPUT 3:
"" Mode: 2
"" ecc_public_key.txt:-
"" {
"" "public_key": "(7 : 13*a + 1 : 1)",
"" "generator": "(8 : 16*a + 7 : 1)",
"" "coefficients": "(2, 3, 5, 7, 11)",
"" "base_field": "17",
"" "field_degree": "2"
"" }
""
"" ecc_private_key.txt:-
"" {
"" "private_key": "2"
"" }
""
"" ecc_ciphertext.txt:-
"" {
""  "ciphertexts": [
""     {
""      "C1": "(10 : 11*a + 16 : 1)",
""       "C2": "(2 : 16*a + 13 : 1)"
""     },
""     {
""       "C1": "(11 : 14*a + 5 : 1)",
""       "C2": "(15*a + 11 : 10*a + 5 : 1)"
""     },
""     {
""       "C1": "(2 : 16*a + 13 : 1)",
""       "C2": "(16*a + 14 : 9*a + 6 : 1)"
""     }
""   ]
"" }
""
"" OUTPUT 3:
"" Decrypted Message Points M:
"" (15 : 10*a + 3 : 1)
"" (4 : 13 : 1)
"" (10*a + 11 : 14*a + 15 : 1)
""
"" Time Taken - 0.687s (Linux x86_64 - ASUS TUF 2022)
""
"" INPUT 4:
"" Mode: 1
"" ecc_public_key.txt:-
"" {
"" "public_key": "(33826589915974876451303538711434911780771211905044168883402609147833006747732 : 27566994943980390140539650248379388081128599148510027697475930812689256311866 : 1)",
"" "generator": "(9 : 14781619447589544791020593568409986887264606134616475288964881837755586237401 : 1)",
"" "coefficients": "(0, 486662, 0, 1, 0)",
"" "base_field": "57896044618658097711785492504343953926634992332820282019728792003956564819949","" "field_degree": "1"
"" }
""
"" ecc_private_key.txt:-
"" {
""  "private_key": "4347824639616818545805935864183075681292255041156396442934508572942088803406"
"" }
""
"" ecc_ciphertext.txt:-
"" {
"" ciphertexts": [
""    {
""      "C1": "(20815982239122993643622767541771961564887253860261512560754879795060097725112 : 55408428385145383705922096339116423514930700177087028503036406932835341516802 : 1)",
""      "C2": "(48233646863068336176964712480031258957406235660873962579024979464585708529465 : 24618939384991165563721350249248700078771366989521946070788597462322721153669 : 1)"
""    },
""    {
""      "C1": "(36971451079847139219210658549707416903951166537404000702159304417996217383612 : 26732569358899894481268901458737827723046460095990255169837292721849592696499 : 1)",
""      "C2": "(28944799660895256369062781483953959837795325626070653946445615325591514953561 : 12869617992734804709246125272408337918664077358362930214567005125069595503998 : 1)"
""    }, ...... (input truncated for brevity)
"" ]
""
""
"""

import sys
import json
from sage.all import *

USAGE1 = "sage Decrypt.py <mode> <priv_key> <pub_key> <ciphertext>"
if (len(sys.argv) != 5):
    print("Invalid Arguments!")
    print(f"\nUsage: {USAGE1}")
    exit(1)


def load_json(filename):
    with open(filename, 'r') as file:
        data = json.load(file)
    return data


def parse_field(base_field, field_degree):
    if field_degree == 1:
        return GF(base_field)
    else:
        return GF((base_field, field_degree), names=('a',))


def parse_coeffs(coeffs_str, K):
    return [K(c.strip()) for c in coeffs_str]


def parse_point(point_str, E):
    point_str = point_str.strip()
    point_str = point_str[1:-1]
    coords = [s.strip() for s in point_str.split(':')]

    if len(coords) != 3:
        raise ValueError("Invalid point format: " + point_str)

    try:
        x = E.base_field()(coords[0])
        y = E.base_field()(coords[1])
        z = E.base_field()(coords[2])
    except Exception as ex:
        raise ValueError(
            f"Invalid coordinate in point: {point_str}. Error: {ex}")

    try:
        point = E(x, y, z)
    except Exception as ex:
        raise ValueError(
            f"Failed to construct point on curve: {point_str}. Error: {ex}"
        )

    return point


def parse_private_key(priv_key_str):
    return Integer(priv_key_str.strip())


def parse_ciphertext(ciphertext, E):
    C1_str, C2_str = ciphertext['C1'], ciphertext['C2']
    C1 = parse_point(C1_str, E)
    C2 = parse_point(C2_str, E)
    return C1, C2


def map_point_to_chars(P):
    if P.is_zero():
        return ""

    X = Integer(P[0])
    msg_chars = ""

    X = X >> 8  # Remove padding byte

    while X > 0:
        char_code = X & 0xFF
        msg_chars = msg_chars + chr(char_code)
        X = X >> 8

    return msg_chars


def main():
    mode = int(sys.argv[1])
    priv = load_json(sys.argv[2])
    pub = load_json(sys.argv[3])
    ciphertext = load_json(sys.argv[4])

    base_field = int(pub['base_field'].strip())
    field_degree = int(pub['field_degree'].strip())
    coeffs_str = pub['coefficients']
    coeffs_str = coeffs_str[1:-1].split(',')
    generator_str = pub['generator']
    public_key_str = pub['public_key']

    K = parse_field(base_field, field_degree)
    coeffs = parse_coeffs(coeffs_str, K)
    E = EllipticCurve(K, coeffs)
    G = parse_point(generator_str, E)
    public_key = parse_point(public_key_str, E)
    private_key = parse_private_key(priv['private_key'])

    if mode == 0:
        C1, C2 = parse_ciphertext(ciphertext, E)
        M = C2 - private_key * C1
        print("Decrypted Message Point M: " + str(M))
    elif mode == 1:
        if 'ciphertexts' in ciphertext:
            msg = ""
            for ct in ciphertext['ciphertexts']:
                C1, C2 = parse_ciphertext(ct, E)
                M = C2 - private_key * C1
                msg += map_point_to_chars(M)
            print("Decrypted ASCII Message: " + msg)
    elif mode == 2:
        points = []
        if not ('ciphertexts' in ciphertext):
            raise ValueError(
                "Mode 2: No valid ciphertexts found in the ciphertext file."
            )
        for ct in ciphertext['ciphertexts']:
            C1, C2 = parse_ciphertext(ct, E)
            M = C2 - private_key * C1
            points.append(M)
        print("Decrypted Message Points M: ")
        for pt in points:
            print(str(pt))


if __name__ == "__main__":
    main()
